commit b71210e22b1dbd833483136659986004aea4452e
Author:     Chris Feist <cfeist@redhat.com>
AuthorDate: Thu Aug 11 17:26:02 2011 -0500
Commit:     Chris Feist <cfeist@redhat.com>
CommitDate: Thu Aug 11 17:26:02 2011 -0500

    Added support for listing available services/fence devices.
    
    Resolves: rhbz#696901

diff --git a/ricci/ccs/ccs b/ricci/ccs/ccs
index 709cb73..4f00e11 100755
--- a/ricci/ccs/ccs
+++ b/ricci/ccs/ccs
@@ -77,6 +77,7 @@ def main(argv):
     nodeid = votes = False
     checkconf = False
     exp = exprm = False
+    lsfenceopts = lsserviceopts = False
 
     global password, debug, sync, hostname, usefile, filename, activate
     global verifyconf
@@ -91,7 +92,7 @@ def main(argv):
       "setlogging", "addlogging","rmlogging","setmulticast","sync","addfailoverdomainnode=", "file=", "nodeid=",
       "votes=", "rmfailoverdomainnode=", "setdlm", "rmheuristic", "startall", "stopall", "activate",
       "setconf", "lsquorum", "lsfailoverdomain", "lsmisc", "checkconf", "exp=", "exprm=", "addunfenceinst=",
-      "rmunfenceinst=","addvm=","rmvm=", "ignore", "debug"])
+      "rmunfenceinst=","addvm=","rmvm=", "lsfenceopts", "lsserviceopts", "ignore", "debug"])
     except getopt.GetoptError:
         usage()
         sys.exit(2)
@@ -206,6 +207,12 @@ def main(argv):
         elif opt in ("--rmvm"):
             removevm = True
             name = arg
+        elif opt in ("--lsserviceopts"):
+            lsserviceopts = True
+            options = args
+        elif opt in ("--lsfenceopts"):
+            lsfenceopts = True
+            options = args
         elif opt in ("--lsquorumd"): listquorum = True
         elif opt in ("--setquorumd"): setquorumd = True; options = args
         elif opt in ("--addheuristic"): addheuristic = True; options = args
@@ -270,6 +277,8 @@ def main(argv):
     if (removeresource): remove_resource(name, options)
     if (addvm): add_vm(name,options)
     if (removevm): remove_vm(name)
+    if (lsserviceopts): list_serviceopts(options)
+    if (lsfenceopts): list_fenceopts(options)
     if (listquorum): list_quorum()
     if (setquorumd): set_quorumd(options)
     if (addheuristic): add_heuristic(options)
@@ -343,6 +352,10 @@ Node Operations:
       --votes <votes>   Specify number of votes when adding a node
 
 Fencing Operations:
+      --lsfenceopts [fence type]
+                        List available fence devices.  If a fence type is
+                        specified, then list options for the specified
+                        fence type
       --lsfencedev      List all of the fence devices configured
       --lsfenceinst [<node>]
                         List all of the fence methods and instances on the
@@ -384,6 +397,10 @@ Failover Domain Operations:
                         Remove node from failover domain
 
 Service Operations:
+      --lsserviceopts [service type]
+                        List available services.  If a service type is
+                        specified, then list options for the specified
+                        service type
       --lsservices      List currently configured services and resources in
                         the cluster
       --addresource <resource type> [resource options] ...
@@ -1183,28 +1200,6 @@ def list_fenceinst(options):
                 print "    " + inst.getAttribute("name") + ": " + getNodeAttr(inst, "name")
     return
 
-
-# Disabling these functions until we get a better idea of how to
-# display fencing options
-#def ls_fencedev():
-#    rng = open(CLUSTERRNG)
-#    dom = minidom.parseString(rng.read())
-#    for elem in dom.getElementsByTagName("group"):
-#        if elem.getAttribute("rha:fence_agent"):
-#            print elem.getAttribute("rha:fence_agent")
-#
-#def ls_fenceinst(fencedev):
-#    rng = open(CLUSTERRNG)
-#    dom = minidom.parseString(rng.read())
-#    for elem in dom.getElementsByTagName("group"):
-#        if elem.getAttribute("rha:fence_agent") == fencedev:
-#            for attr in elem.getElementsByTagName("attribute"):
-#                attrname = attr.getAttribute("name")
-#                invisible_attrs = ["verbose", "debug", "version", "help",
-#                        "option", "action", "separator"]
-#                if attrname not in invisible_attrs:
-#                    print attr.getAttribute("name") + " - " + attr.getAttribute("rha:description")
-
 def add_service(name, options):
     dom = minidom.parseString(get_cluster_conf_xml())
 
@@ -1500,6 +1495,107 @@ def remove_vm(name):
 
     set_cluster_conf(dom.toxml())
 
+# Print out all the available service options from the cluster.rng file
+def list_serviceopts(options):
+    if len(options) == 0:
+        servicename = None
+    else:
+        servicename = options[0]
+
+    rng = open(CLUSTERRNG)
+    dom = minidom.parseString(rng.read())
+
+    for elem in dom.getElementsByTagName("define"):
+        if elem.getAttribute("name") == "CHILDREN":
+            for elem2 in elem.getElementsByTagName("ref"):
+                if servicename:
+                    if elem2.getAttribute("name").upper() == servicename.upper():
+                        (servname, servopts) = getServiceOptions(dom, elem2)
+                        print servname
+                        print servopts
+                else:
+                    (servname, servopts) = getServiceOptions(dom, elem2)
+                    print servname
+
+def list_fenceopts(options):
+    if len(options) == 0:
+        fencename = None
+    else:
+        fencename = options[0]
+
+    rng = open(CLUSTERRNG)
+    dom = minidom.parseString(rng.read())
+
+    for elem in dom.getElementsByTagName("define"):
+        if elem.getAttribute("name") == "FENCEDEVICEOPTIONS":
+            for elem2 in elem.getElementsByTagName("group"):
+                if fencename:
+                    if elem2.getAttribute("rha:name") == fencename:
+                        (fencelongname,fenceopts) = getFenceOptions(dom, elem2)
+                        print fencelongname
+                        if fenceopts == "":
+                            print "No description"
+                        else:
+                            print fenceopts
+                else:
+                    (fencelongname,fenceopts) = getFenceOptions(dom, elem2)
+                    if fencelongname: print fencelongname
+
+                    
+def getServiceOptions(dom, elem):
+    name = elem.getAttribute("name")
+    for elem in dom.getElementsByTagName("define"):
+        if elem.getAttribute("name") == name:
+            elem2 = elem.getElementsByTagName("element")[0]
+            description =  elem2.getAttribute("rha:description")
+            if not description:
+                description = "No description available"
+            longname = elem2.getAttribute("name") + " - " + description
+            options = getOptions(elem2)
+            return (longname, options)
+    return (False, False)
+
+def getFenceOptions(dom, elem):
+    if not elem.getAttribute("rha:name"):
+        return (False, False)
+    description =  elem.getAttribute("rha:description")
+    if not description:
+        description = "No description available"
+    longname = elem.getAttribute("rha:name") + " - " + description
+    options = getOptions(elem)
+    return (longname, options)
+        
+
+def getOptions(elem):
+    optionalOptions = []
+    requiredOptions = []
+    retval = ""
+    for elem2 in elem.getElementsByTagName("attribute"):
+        if elem2.parentNode.nodeName != "optional":
+            if elem2.getAttribute("name") != "ref":
+                requiredOptions.append(elem2)
+        else:
+            optionalOptions.append(elem2)
+    retval += "  Required Options:\n"
+    for elem2 in requiredOptions:
+        description = elem2.getAttribute("rha:description")
+        # Remove excess whitespace some attributes have
+        description = re.sub("\s\s+", " ", description)
+        name =  elem2.getAttribute("name")
+        if not description:
+            description = "No description available"
+        retval += "    " + name + ": " + description + "\n"
+    retval += "  Optional Options:\n"
+    for elem2 in optionalOptions:
+        description = elem2.getAttribute("rha:description")
+        # Remove excess whitespace some attributes have
+        description = re.sub("\s\s+", " ", description)
+        name =  elem2.getAttribute("name")
+        if not description:
+            description = "No description available"
+        retval += "    " + name + ": " + description + "\n"
+    return retval
+
 def list_quorum():
     xml = get_cluster_conf_xml()
     dom = minidom.parseString(xml)
@@ -1962,7 +2058,13 @@ def send_to_ricci(msg, host=hostname):
     cert = os.path.expanduser("~/.ccs/cacert.pem")
     key = os.path.expanduser("~/.ccs/privkey.pem")
     config = os.path.expanduser("~/.ccs/cacert.config")
-    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
+    try:
+        (family, socktype, proto, canonname, sockaddr) = socket.getaddrinfo(host, RICCI_PORT)[0]
+    except socket.gaierror:
+        print "Unable to resolve %s, does that host exist?" % host
+        sys.exit(1)
+    
+    s = socket.socket(family, socktype, proto)
 
     # Make sure we have a client certificate and private key
     # If not we need to autogenerate them (including creating an
diff --git a/ricci/ccs/ccs.8 b/ricci/ccs/ccs.8
index ab21a1c..d0a4595 100644
--- a/ricci/ccs/ccs.8
+++ b/ricci/ccs/ccs.8
@@ -75,6 +75,10 @@ Specify nodeid when adding a node
 .IP "--votes <votes>
 Specify number of votes when adding a node
 .SS "FENCING OPERATIONS"
+.IP "--lsfenceopts [fence type]
+List available fence devices.  If a fence type is
+specified, then list options for the specified
+fence type
 .IP "--lsfencedev
 List all of the fence devices configured
 .IP "--lsfenceinst [<node>]
@@ -111,6 +115,10 @@ Add node to given failover domain
 .IP "--rmfailoverdomainnode <failover domain> <node>
 Remove node from failover domain
 .SS "SERVICE OPERATIONS"
+.IP "--lsserviceopts [service type]
+List available services.  If a service type is
+specified, then list options for the specified
+service type
 .IP "--lsservices
 List currently configured services and resources in
 the cluster
